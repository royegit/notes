


//安装 nodemon 使用国内的淘宝源
npm install nodemon -g --registry=https://registry.npm.taobao.org 

XSS攻击

反射型 	 存储型

<a href='javascript:alert(1);' />
<img src='abc' onerror='alert(1)' />

CSRF攻击
<img src="攻击地址及参数<a href='链接地址'></a>" />

防止XSS攻击：
		对用户提交的表单如果如果我们不希望用户提交的内容有除文字以外的内容提交，这时我们可以对内容进行转义。把内容中的 < &lt;和 > &gt转义
		
		function escapeHtml(str){
			if(!str) return '';
			str =str.replace(/&/g,'&amp;'); //&符号的转义只能放到最前面，如果放到最后面。那下面所有的转义符号&lt等都会被再次转义
			str =str.replace(/</g,'&lt;');
			str =str.replace(/>/g,'&gt;');
			str =str.replace(/"/g,'&quto;');
			str =str.replace(/'/g,'&#39;');
			//str =str.replace(/ /g,'&#32;');  //空格可以不转义
			
			return str;
		}
		把所有的内容都传进去进行转义。
		但是就这样还不能算是安全的还需要把"双引号"和'单引号'同时转义了
		
		关于空格的转义，因为HTML内容中的多个连续的空格在渲染中只会产生一个空格，比如一个html中有5给空格是连续的，但是在页面中只会产生一个空格。如果我们都将所有的空格都转义成HTML实体的时候页面中的显示可能会有问题
		因此一般来说我们对空格不做转义，当对空格不做转义的时候我们就需要注意我们的属性一定要有引号(")
		按照HTML的规范在HTML五之前&这个符号本身也需要转义的而在HTML五之后这个(&)这个符号可以不做转义，因此这个（&）符号做不做转义都是一样的，但是按照惯例来说还是要做一下转义的
		
		上面的方法只能针对html的因为在javascript中是不认识html实体的所以以上的html实体字符放到javascript中会被完整输出
		所以我们需要针对javascript在做另一个方法
		
		function escapeForJs(str){
			if(!str) return '';
			str = str.replace(/\\/g,'\\\\"');
			str = str.replace(/"/g,'\\"');
			
			return str;
		}
		这种办法虽然在某种程度上解决了js防止XSS攻击的但还不是绝对的，最绝对的方法是使用JSON.stringify();
		
		JSON.stringify(str);
	
防止XSS攻击：
	富文本篇：
		富文本防xss攻击一般主要是放在输入之前，做过滤因为如果每次输出都过滤用户的内容会影响页面的性能
		
		function xssfilter(){
			if(!html) return '';
			html = html.replace(/<\s*\/?script\s*>/g,'');
			html = html.replace(/javascript:[^'"]*/);
			html = html.replace(/onerror\s*=\s*['"]?[^'"]*['"]/g,'');
			return;
		}
		
		以上方法只能针对过滤规则有效的能防止XSS。但是XSS攻击的方法多种多样每加一个规则总能找到另一种规则绕过去，如onmouseover ,onfocusin,svg等各种标签都可以用来xss攻击
		那这种情况我们只能用白名单来进行过滤了。
		
		node.js 的 cheerio 白名单
	
	
	csp 防御XSS（在node.js中）
	child-src connect-src  default-src     <host-source><scheme-source> 'self'
	font-src frame-src img-src 			   'unsafe-inline unsafe-eval' 'onoe'
	manifest-src media-src object-src 	   'nonce-<base64-value>'  <hash-source>
	script-src style-src worker-src 	   'strict-dynamic'
	
	ctx.set('Content-Security-Policy','default-src \'self\'');
	
	PHP 防御XSS
		内置函数转义
		
		DOM 解析白名单
		
		第三方库
		
		csp
	
		<?php
	
		header('X-Xss-Protection:0');//关掉XSS保护
		
		//csp 防止XSS攻击，用这个头后虽然用户可以提交XSS代码，但是到页面显示是XSS攻击代码失效(让不安全不信任的内容不能运行)
		header("Content-Security-Policy:default-src 'self'");
		
		
		if(strtolower($_SERVER['REQUEST_METHOD'])=='post'){
			$content=$_POST['content'];
			//$content=strip_tags($content); //strip_tags 移除所有的html标签
			$content=htmlspecialchars($content,ENT_QUOTES);  //对一些字符转义
		}
	
	
		<div><?php echo $content; ?></div>
		
		?>
		
		
		<form method='post'>
			<textarea name='content'>hello</textarea>
			
			<button type='submit'>提交</button>
			<button type='submit'>提交</button>
		</form>
	
	
	PHP 防御XSS之富文本
		
		The DOMDocument class //防止富文本XSS攻击 DOMDocument 解析白名单
		
		
		第三方库防止富文本XSS攻击
		HTML PURIFIER
		http://htmlpurifier.org/  官方下载地址
	
			<?php
	
				header('X-Xss-Protection:0');//关掉XSS保护
				
				require_once './HTMLPurifier.auto.php';
				
				if(strtolower($_SERVER['REQUEST_METHOD'])=='post'){
					$content=$_POST['content'];
					
					$purifier=$purifier->purify($content);  //调用purify方法过滤script等一些危险的标签
				}
			
			 
				<div><?php echo $content; ?></div>
				
			?>
		
		
		<form method='post'>
			<textarea name='content'>hello</textarea>
			
			<button type='submit'>提交</button>
		</form>


防止 CSRF 攻击
	Cross Site Request Forgy
	跨站请求伪造
	
	特征：
		1、B网站向A网站请求
		2、带A网站Cookies
		3、不访问A网站前端
		4、referer为B网站
		
	针对这几个特征的解决方案：
		1、禁止第三方网站带Cookies   same-site属性（这种方法只在chrome有效）
		2、加入验证码和token
		3、验证 referer 禁止来着第三方网站的请求
		
		
		
		
		
		PHP same方法
		header('Set-Cookie:test=12345; SameSite=Lax');
		
		referer方法
		
		if($_SERVER['HTTP_ERFERE']){
			$isLegal=strpos($_SERVER['HTTP_REFERER'],'http://websecurity.local/')===0;
			var_dump($isLegal);
		}
		
		
		token:
		
		$csrfToken='123456';
		setcookie('csrfToken',$csrfToken);
		
		表单
		<input type='hidden' name='csrfToken' value="<?php echo $csrfToken; ?>">
			
		
		然后 cookie的token 和表单提交的 token 对比验证
		
		
	
		一个简单的SCRF攻击请求
		<script>
			document.write(
				'<form name="commentForm" target="csrf"
					method="post" action="http://localhost:1521/post/addComment">
				<input name="postId" type="hidden" value="13">
				<textarea name="content">来自CSRF!</textarea>
				</form>'
			);
			var iframe=document.createElement('iframe');
			iframe.name='csrf';
			iframe.style.display='none';
			document.body.appendChild(iframe);
			
			//当页面被浏览时执行提交请求
			setTimeout(function(){
				document.querySelector('[name=commentForm]').submit();
			},1000);
		</script>
	
	
	
		cookies特性
			前端数据存储
			后端通过http头设置
			请求时通过http头传给后端
			前端可读可写
			遵守同源策略
			
			域名，同一个域名小有效
			有效期，有效期内有效
			路径：URL的层级，其他页面的层级访问不到。只能下级访问上级顶层访问不到下级
			http-only:只有http协议可以使用，可以在请求的发送和接收中使用cookie,javascript是不能使用cookie的
			secure:是指cookie是否只是在https的网站中使用，当使用http协议时是无法使用的
			
			
			
			用户退出登录后用cookie保留用户ID以便用户下次访问时即使没登录也能保留上次的访问页面
			但是如果单独只是使cookie保留用户ID其实是有安全隐患的，因为用户ID是可以轻易被串改看，那该怎么办呢。
			这是我们可以使用id+签名的方法，保证签名的方式只有我能算出来其他人算不出
			sessionId
			
		cookies和xss关系
			xss可能偷Cookies
			http-only的Cookie不会被盗
			
		cookies和csrf关系
			csrf利用用户cookies
			攻击站点无法读写Cookies
			最好能阻止第三方使用Cookies
			
	
	
			
	点击劫持
		点击劫持特点
		
		用户亲手操作
		盗取用户资金（转账，消费）
		用户不知情
		获取用户敏感信息
			
		<iframe style='opacity:0' src='http://localhost:1521/post/15' width='800' height='600'>
		</iframe>
		iframe 是链接的目标网站但是目标网站是在iframe里是透明的，以达到隐藏的作用让用户不知道自动点击这个是干什么用的
		
		
		点击劫持的原理就算将目标网站作为一个iframe嵌入到攻击者的网站中，然后将iframe隐藏让用户看不到目标网站的界面。然后引导用户点击，执行攻击。
		所以我们可以用禁止iframe内嵌的方法来应对点击劫持
		
		javascript的方法
			如果父级页面不等于当前页面，父级页面跳转到当前页面
			if(top.location!=window.location){
				top.location=window.location;
			}
			但是这样并不能完全解决问题因为攻击者可以利用iframe的sandbox="allow-forms"机制来限制js脚本的执行这样我们设置的js点击劫持就没办法执行。
			
			第二种方法就是
			
			加一个头部禁止网站内嵌，或是之允许指定的网站内嵌，或是只允许本网站进行内嵌（兼容性好推荐使用）
			header('X-Frame-Options:DENY');
			
	
	
	
	传输安全：
			意思就是需要配置https
		
		
		怎样知道我们访问的网站从我的电脑到达服务器需要经过那些节点呢？
		
		windows 上
		tracert    test.zouba.cn  
		
		linux 上
		traceroute test.zouba.cn
		
		[root@localhost ~]# traceroute test.zouba.cn
		traceroute to test.zouba.cn (120.79.3.86), 30 hops max, 60 byte packets
		1  gateway (192.168.0.1)  1.824 ms  4.055 ms  4.028 ms
		2  192.168.1.1 (192.168.1.1)  2.620 ms  2.666 ms  2.783 ms
		3  124.42.162.1 (124.42.162.1)  84.137 ms  84.651 ms  84.680 ms
		4  10.144.13.14 (10.144.13.14)  84.321 ms 10.144.12.202 (10.144.12.202)  84.321 ms 10.144.12.194 (10.144.12.194)  84.306 ms
		5  * 14.197.242.137 (14.197.242.137)  84.591 ms 14.197.242.141 (14.197.242.141)  84.494 ms
		6  14.197.149.54 (14.197.149.54)  84.126 ms  73.632 ms  66.004 ms
		7  42.120.242.226 (42.120.242.226)  65.904 ms 116.251.113.146 (116.251.113.146)  65.869 ms 116.251.113.162 (116.251.113.162)  65.855 ms
		8  42.120.253.6 (42.120.253.6)  66.177 ms 116.251.117.157 (116.251.117.157)  167.815 ms 116.251.117.153 (116.251.117.153)  144.048 ms
		9  11.217.38.237 (11.217.38.237)  147.028 ms  147.009 ms 11.217.38.205 (11.217.38.205)  146.976 ms
		10  11.220.36.129 (11.220.36.129)  149.153 ms 11.220.37.137 (11.220.37.137)  149.162 ms 11.220.37.117 (11.220.37.117)  146.976 ms
		11  * * *			// *号表示这给节点没有按我们想要的返回数据但是访问的时候它会把数据进行转发
		12  * * *	
		13  * * *
		14  * * *
		15  * * *
		16  * * *
		17  * * *
		18  * * *
		19  * * *
		20  * * *
		21  * * *
		22  * * *
		23  * * *
		24  * * *
		25  * * *
		26  * * *
		27  * * *
		28  * * *
		29  * * *
		30  * * *
		
		
		
		可以看到这中间经过了20多给节点，这里的每一个节点都有能力查看或是修改我们的数据
		怎么样确实中间的节点是可以查看我们的数据的呢？
		
		我们可以先查看一些localhost ，localhost走的是本地回环的路线
		
		[root@localhost ~]# traceroute localhost
		traceroute to localhost (127.0.0.1), 30 hops max, 60 byte packets
		1  localhost (127.0.0.1)  0.043 ms  0.020 ms  0.011 ms

		我们可以看到他只有一个节点
		那我们怎么样在中间加入一些别的东西呢 ？
		我们看到这个地方的浏览器和服务器是在一台服务器上。我们只能强行在中间加入一层代理服务器
		
		anyproxy 是一个代理软件，这个代理软件启动后它会在本地8001端口开启一个代理
		第二件事请就是在8002端口开启一个管理界面。 在浏览器的地址拦上输入本地ip加上8002端口(http://192.168.0.101:8002)后就可以看到所有经过的它代理的请求
		打开chrome的代理插件->选项->anyproxy->代理服务器  设置代理服务器和端口注意 在下面有一个 "部代理列表" 它是设置部经过代理的地址池，
		如果我们设置 localhost 然后访问localhost他就会跳过localhost但是现在不用
		然后我们访问目标网站然后打开 anyproxy 是可以看到访问地址的请求信息还有返回信息的都是揽无余的，
		除了窃听之外我们还可以串改
		串改的意思就可以把返回的内容改掉
		我们可以到http://192.168.0.101:8002(这个地址有可能是目标网站的地址，由于没有实测过)中串改任何内容
		
		
		
		还可以看到所有经过这个代理服务器的网站的所有请求的用户名和密码，敏感信息，等等所有的信息
		
		可以插入广告，因为广告也很可能是中途被人插入进来的
		重定向网站，本来访问的是a网站却跳到了b网站，这是因为http的响应可以被随意的修改，修改之后我就可以直接给你返回301，302要么就可以直接给你跳走
		要么用js或是header头把你重定向到别的网站（很流氓的方式）
		
		无法防御的XSS和CSRF攻击
			虽然我们之前做了很多对XSS和CSRF攻击的防御措施但是如果http可以被随意的修改那实际上我们所有的防御都是无效的HTTP头被修改我们的代码也可以被修改
			我们转义过的内容他还可以在转义回来
		
		
		https://letsencrypt.org/    // https申请免费证书
		
		在部署https的时候如果网站有的链接是http的链接浏览器就会有提示非完全安全的网站
		
		
	密码安全：	
		
		
		给每一个用户生成一个盐在加上固定字符串加上密码在加上用户密码。
		MD5(sha1(md5(ID+ab83kd+原始密码+81kdso+盐+1lso;$2)));
		

		
		
		密码传输安全：
		https传输
		频率限制 ，如果过于频繁的登录就用户登录
		前端加密意义有限
		
		生物特征密码
		指纹
		声纹
		虹膜(人眼)
		人脸

		私密性-容易泄露(人脸，指纹)
		安全性-碰撞（具有相似度的人有可能会破解）
		唯一性-终身唯一无法修改
	
	
	关系行数据库：
		存放结构化数据库
		可高效操作大量数据
		方便处理数据之间的关联关系
		
		常见：
		access （微软，后缀mdb,小型系统） 
		sqlite:（主要用于嵌入式设备，可移植的文件行的数据系统，比如手机的app，只能设备，表现形式数据文件，后缀点DB,功能比较完善性能也不是特别好）
		mysql:()
		mssql server:(收费);
		
		
		sql 注入的神奇语法
		select * from table where id='10' and 1=0;
		select *from table	where id='10' or 1=1;
		select *from table where id='10' and mid(version(),1,1)=5;
		select 1,2,3 from table;
		select id,1,2,3,from table;
		select *from table union select 1,2,3 from table2;
		select *from table where mid(username,1,1)='t';
		
		判断有没有sql注入
			如果有一篇文章后面带有文章的id时 在文章后面加 and 1=1 如果发现能把文章查出来 如果加 and 1=0也能查出来 然后在加上 and 1=2 
			也就是说如果是恒等于页面就报错如果是恒不等于页面就报错这个时候页面就会有注入的问题
		
			sql注入防御：
				关闭错误输出
				
				
				第一，检查数据类型
				$id=intval($_GET['id']);
				
				第二，对数据进行转义 addslashes
				//$id=addslashes($_GET['title']);
				
				
				//专门为mysql提供的转义函数(这个函数是依赖于数据库链接所以需要放在mysql链接之后的函数下面)
				//$id=mysql_real_escape_string($_GET['title']);

				
				$conn=mysql_connect('localhost','root','root');
				mysql_select_db('safety',$conn);
				$sql="select *from post where id='".$id."'";

				
				
				第三，使用PDO参数化查询
				//pdo链接数据库
				$conn= new PDO('mysql:host=localhost;dbname=safety','root','',[]);
				//查询数据库
				$stmt=$conn->prepare("SELECT *FROM post where title like :title");
				$stmt->execute(['title'=>'%'.$title.'%']);
				
				第四种，使用ORM(对象关系映射)
				因为PHP和html的代码是混在一起的，如果使用ORM的话维护成本很高。但是PHP的开发有框架支持ORM 只要调用框架的ORM就可以 PHP不用考虑
				
				$result=mysql_query($sql);
				$row=mysql_fetch_array($sql);
				var_dump($row['id'],$row['title'],$row['content']);
				mysql_close($conn);
				if(strtolower($_SERVER['REQUEST_METHOD'])=='post'){
					$content=$_POST['content'];
				}
				
				
		上传安全：
				
			上传问题防御
				1、限制上传后缀（如果是PHP的服务器，就不能上传PHP的后缀，不然就会被解析。如果是node就不能上传js文件）
				2、文件类型检查（文件类型虽然是浏览器给的，但是也不是绝对安全的因为作为攻击者他可以用任何手段给你发http请求修改你的type类型）
				3、文件内容（不同的文件的内容有不同的头，也就是各种类型的文件它开头的几个字符都是有一定特征的。我们可以根据特征去做一下检查。那这种是不是完全没有办
				法了呢？其实也不是，因为php这种文件它可以是html和php混写的如果在php开头写上文件类型的头特征(比如开头内容我写个git头特征)然后在后面写php代码，这种方
				法完全可以欺骗过去）
				4、程序输出（）
				5、权限控制-可写可执行互拆（在某一情况下的最低安全保障）
				
				1、限制上传后缀
				
					$files=pathinfo($_FILES['img']['name']);
					
					if($files['extension']!='png'){
						echo "不是png文件不可上传";
					};
					
					
					
				2、文件类型检查
				
					if($_FILES['img']['type']!='image/png'){
						echo '不是png文件不可上传';
					}
					
					
					
				3、文件内容检查
					
					$info=finfo_file(finfo_open(),$_FILES['img']['tmp_name']);
					if($info!='文件特征字符'){
						echo '不是png文件不可上传';
					}
				
				4、程序输出（劣势是性能消耗大）
					$file=file_get_contents('./test.php');
					header('Content-Type:text/plain');
					die($file);
				
				DOS  	
					TCP  半联结
					HTTP 链接	
					DNS  
				
				DDOS  大规模分布式拒绝服务攻击DDOS
					（和DOS的区别是DOS一般是一台机器或是少量的几台机器，但是ddos就会有大量的机器）
				
					流量可大几十到上百G（每一秒钟有几十上百G的流量涌到你的机器）
					分布式（肉鸡、代理）
					极难防御（就算你有方法区分那些用户是正常用户那些是不正常的用户，但是很多时候也没有办法。因为但有几十上百G的流量过来的时候他很可能就会占用非常多
					的机房，甚至把整个机房的流量沾满甚至更极端的他能把一个城市一个省份的出口流量沾满。达到这个级别的时候一般不用你去防御，这个时候电信或是机房就会
					把你的机器下了，这时你其实是没有事情可以做的，唯一可以做的就是等着攻击停下来然后运营商把你的机器放到网上）
					
					
				DOS 攻击案例
				2009 年 5月19日
					全国多省市断网
					1、游戏私服互相攻击DDOS（互相有竞争关系然后就互相攻击，然后发现攻不下来可能是流量不够大）
					2、换目标，攻击DNS服务器（攻不下来的时候他就换了个目标去攻击DNS服务器，因为你要访问的话就必然要用到域名解析吗，然后就去攻击域名解析的服务器）
					3、DNS服务器机器下线（域名解析受到大流量的攻击之后，运营商或是机房的管理者就会把你的机器下线）						
					4、数十万网站DNS解析瘫痪（下线之后，因为DNS并不只是服务游戏私服一家公司他会服务非常非常多的网站，这家DNS服务商他提供了几十个网站的DNS解析在同一台
					服务器上，那这台服务器被下架之后就导致国内数十万的网站DNS解析瘫痪）
					5、暴风影音后台疯狂请求解析（这几十万中就有暴风影音的网站，也是使用了这家DNS的提供商。这是就有一件事情非常巧合，暴风音音安装之后他有一个后台进程，
					也就是不管你开不开暴风影音它都会在后台，这个后台他就会向他的网站发起请求当请求失败之后它会不段的尝试重试，当不段的重试之后中间就会达到非常大的量级
					导致DNS的请求越积越多而且这些请求是来自于全国各地因为国内各个省份都有安装暴风影音）
					6、各地local DNS瘫痪无法上网（那这些请求最后导致各个地方的各个省份的本地DNS服务器瘫痪，也就是这个量越来越大越来越大导致本地的如电信联通他们的服务
					器也受不了了也瘫痪，瘫痪之后就上部了网是，你每一个人都没有地方去解析DNS了。因为部管你用的是什么服务商他都要经过本地电信运营商的的DNS，而当这个
					local瘫痪之后就导致无法上网。那这些事情下来当天就导致了全国有几十个省份是无法上网的，这是一个非常恶性的事件同时也可以反应出DDOS他的攻击力之强以
					及他的防御之困难）
					
				DOS攻击防御：
					1、防火墙
					2、交换机、路由器
					3、流量清洗
					4、高防IP（商业服务）（高防IP就是一些云服务厂商提供的服务当你受到攻击的时候他会给你一个IP，然后让你的域名只向这个IP也就是说当用户访问的时候是访
					问的是高访问的IP也就是说当攻击者攻击的时候流量也会到这个高防的IP，那这个高防IP对应的就是大规模的流量清洗服务它会把流量拦劫然后给你留下用户正常的
					流量。这个高防IP背后其实还有一个就算云服务厂商它能够提供非常大的带宽刚刚说过DDOS攻击它的流量可以达到几十上百G的流量而国内目前能够提供这种量级防
					御的也就云计算的厂商，所以这就是他们能够提供高防IP进行DDOS防御的一个优势）
					
				其实这也是非常有限的防御措施
					那我们在开发的时候也可以做一些预防措施的。DOS或是是DDOS它的原理其实就是发起大量的请求。那这也就意味着如果你的服务没有被运营商下线那考验的就是你
					服务去的承载能力了，如果你服务的承载能力越高那你能承受的攻击也就约大。
					那这样的情况下我们可以做一些措施去预防。
					
					比如：
					
					避免一些重逻辑的业务（就是说当用户访问的时候你应该非常快速的完成这个业务逻辑，而不是用户访问一些需要花一两秒才能完成返回。这样的话你的服务器的负
					载能力就会下降的非常多。当你的逻辑做的非常清的时候你能承受的访问量就会非常大这个时候被攻陷的情况就会少很多）
					如果有一些逻辑就是需要很麻烦该怎么办？比如当用户访问的时候我要生成一个PDF文件这场景有可能就会花费数秒钟的时间怎么办？这时你可以把用户生成的文件和
					用户的访问拆开。用户访问的时候我只是产生一个任务我要生成一个PDF然后就告诉用户你的任务正在生成。
					那生成PDF就不要放到你最前端的跟用户直接接触的服务器有可能你放到后面专门的一台服务器去做。那这台服务器他可以有一些排队机制先做最前面的然后在做下一
					个，保证这台生成PDF的服务器它是不会过载的，你可能会排队很长但你永远不会负载过高，同时接触用户的这端的服务器他仅仅只是生成任务排个队他的逻辑也不会
					很重。这样的话负载能力就会高很多。
					
						快速失败快速返回（当你有时候碰到问题失败的时候需要快速失败快速返回，这个可能跟我们做开发的时候刚好是相反的，当我们进行一个操作的时候很多时候
					我们都会考虑如果过这个操作失败了怎么办，那很容易相到如果失败了那我就重试咯。如果在失败我在重试一次有可能你会重试3次4次5次这样的情况如果有一次成功
					就能正常返回给业务但是这样会导致你负载能力下降。
						比如当你的系统已经负载量很高的时候这个时候失败的概率也会加大，因为你负载越高任务就越有可能失败，那么当你失败的时候你的程式会继续触发你的逻辑
					那也就是说你负载越高的时候你重试的越多你失败的也就越多然后你又触发重试，这个时候失败的就会越来越多重试越来越多服务器负载就会越来越高，
						所以当你觉得你的业务有可能存在负载瓶颈的时候或者有可能被攻击的时候记得我们要快速的失败快速的返回，只要失败了马上告诉他失败了后面的事情都部
					做了。那用户他可能需要他可能会隔个3秒5秒在给你一次请求这个时候你的重试就会少了很多）
					
					防雪崩机制
					（刚刚说过你到如果你失败之后反复的重试那有可能你的东西就会越积越多越积越多负载会越来越高，这个时候你的系统其实就相当于发生了雪崩。那所谓雪崩就是说
					有一个地方比如说一片雪山有一个地方崩掉了之后那整个雪山都会崩塌，这种现象其实在系统中也是一样当你的任务越积越多越积越多这个时候你的失败就会一个接一
					个的失败然后失败的越多重试的越多就会导致任何越来越多那这样是一个恶性循环向滚雪球一样越滚约大越滚越大你的系统最好就会彻底挂掉
						那怎样去防止这种雪崩机制呢？从机制来讲首先你需要快速的失败快速的返回这是我们刚刚说过的 第二种就是你要清楚你系统的负载比如你的系统能同时负载多少
						个用户能够每秒钟处理多少个请求当我的请求数快要达到这个极限的时候我就可以先把一些请求拦下来。比如我的业务是每秒处理两千给请求当我的请求量现在已经
						达到1900的时候我就随机的10%直接返回失败这个其实是对系统的一个非常好的保护让它不要真的达到崩溃的边缘一旦达到了之后你后面处理的失败就会越来越高
						相反如果你预先去防御比如有10%的失败了那有可能我的负载永远在1900永远失败率只有10%它不会崩掉）
					
					有损服务
						（有损服务的意思是我允许我的业务是部正常的，我们经常看到的是如果我们的系统是有很多业务组成只要有一个系统挂了那么你的整个业务就会挂这个就会导
						致你的系统负载能力很低因为他取决于你系统中负载能力最低的那个。如果它的负载很低那你的整个系统的负载能力就只有那么低
							但有损服务是什么意思尼？就是你的系统有很多服务组成当你有一个服务挂掉了之后我可以部影响其他服务我只是这一部分部可用那这是一个非常重要的思
							路，当你的系统负载有问题的时候如何保证有一部分功能是可用的或是保证核心业务是可用的这个是非常重要的）
							
					CDN
						（CDN他并不能完全解决问题，一般来说限制我们的CDN主要是用来解决静态文件那么着呢，有一部分一部分的作用就是减少我们服务器的负载我们把静态文件分
						发到CDN上面去用户访问CDN这部分的请求不会到我们的服务器减少我们服务器的负载，但是对于动态请求CDN的表现目前不是特别理想当然有理想的动态CDN我们
						也可以尝试去部署这样的话可以极大的减轻我们服务器的压力）
					
					
				重放攻击：
					请求被窃听或记录
					再次发起相同的请求
					产生意外的结果
					
					防御 
					加密（hTTPS）
					加时间戳
					token(session)(一次性后端生成)
					nonce
					签名（特别是支付、抽奖、投票）
					
					
				课程总结：
					请简述XSS的原理
					跨站脚本攻击他的原理就是用户的数据，那有可能是我们的一篇文章一个评论或者是浏览器访问的一个参数。总之是来着用户的数据最好被当成脚本在页面中执行了，
					那这执行的地方有可能是在我们的script标签内也有可能是我们其他一些标签的属性或者是一些富文本中等等。
					最根本的就是本来是一个数据被当成了一个脚本变成了一个程序
				请简述XSS的防御方法
					XSS的防御主要有两种思路第一种思路就是不要让这个数据变成程序第二种就是这个程序变成程序之后我也要让它没办法执行因此对应的方法有这样的几种，
					第一种流量器内置了对XSS反射型的防御当它检测到一个反射型XSS的时候会进行拦劫
					第二种就是对我们的数据进行适当的转义，那这个转义包括在正文中的转义包括在属性中的转义包括在脚本中的转义。我们会转义的字符主要包括（ < , > , ' , " 
					, & ）这几个符号那
					第三种方法就是针对我们不能将html标签全部过滤的或者转义的情况比如说富文本因为富文本的样式正是靠html来产生的那这种情况我们只能使用白名单进行转义。
					白名单的意思就是把我们的这段代码解析成具体的html数然后对这html数进行分析， 那一些标签是可以保留的哪一些属性是可以保留的最好在变成一个html字符串
					第四种方式就是使用cs
					
				XSS防御需要注意的点
					最根本的就是转义的时候他的使用场景和范围比如你是在一个script标签 这样的场景的话那我有可能需要转义大于号小于号如你是的html中那我有可能需要转义引号
					如果是富文本呢那我只能通过白名单的方式。这里一定要注意的是场景和对应的方法	
					
				CSRF原理是什么
					那他的原理就是流量器在访问我们的时候会带上cookie,当一个第三方的网站比如通过图片或者是通过表单提交的方式来访问我们的时候这个时候的cookie也是带上
					的那带上的过程中呢就表示我知道这个用户的身份那就会利用这个用户的身份去做一些操作
					而这过程中因为是从第三方网站静默的发起的所以其实用户根本不知情（所以csrf最根本的就是在用户不知不觉中对目标网站发起了请求而这个时候是带有用户身份
					的。）
				csrf的危害是什么
					那就是一切盗用用户身份可以去做的事情都可以叫做危害比如冒名发帖然后模拟用户去做消费，然后让用户去发一些不好的言论。只要是用户身份可以去做的那csrf
					都可以去做并且是在用户在不知情的情况下
				CSRF如何进行防御
					第一，就是不让用户第三方的请求带cookie就可以防止第三方请求盗用用户身份了中主要是通过 SameSite 但是SameSite只支持chrom所以他的应用范围有限
					第二，就是增加用户的感知，比如需要带一个验证码这样的方式就是在用户在不进行操作的情况向没有办法静默的发表一些言论或者请求没有办法进行。
					第三，就是增加token这个token是我们同时写到我们网站的页面表单以及cookie中这样的话第三方访问的时候他没有办法读取cookie那这样的话他就没有办法对这个
					token进行一个正确的发送这样我们就可以判断这个请求是不合法的 
					第四，就是通过 referer 当检测到来源是通过一个第三方网站的时候我就认为这是一个不合法的请求将它进型拦截那这个就是一个csrf的一个防御方式 
					
					
				Cookie的作用是什么	
					Cookie从计术上将他在浏览器端存储一个数据这个数的量不会很大他会比较持续的存在除非当他的有效时间到了否则它是不会随着浏览器的关闭而消失的所以可以持
					续一段时间
					那到应用层面我们可能会用他存储一些这样的数据，比如说网站的配置比如你这个用户的偏好是什么或者你之前做了什么个性化的选择那还可以存在比如一些用户身
					份的标识，
					当你登录的时候我就会往你cookie里面放一个标识，用于后续的身份识别，
				
				Cookie和Session的关系
					session是用户存储一些跟用户相关的也就是说当你登录的时候你的每一次请求我都是需要去关注的比如说你是谁比如你的登录态等等我都会放到sessio中那session
					和cookie的关系呢
					session是在服务端实现的但是session他需要有个标识需要你告诉我你这个人对应的是那一个session 那这个标识我们是放到cookie中。也就是说当我要开启一个
					session的时候我就会给一个标识给
					给到cookie里面下一次当你访问的时候我就会把这个标识带过去才能取到对应的session也就是说session是基于cookie的存储来实现的的那session也还有其他的。
				Cookie有哪一些特性呢？
					比较常用的就是，比如他的容量是有限制的比较小，它会跟随html去发送，它是根据http头去发送过去的。它可以通过js读取。
					我们这里最关注的是它的几个属性那这几个属性主要是包括域名，因为有域名的话它是不能跨域的这是cookies的一个重要的特性
					第二个就是他的路径，在同一个域名下你的path不一样的话读取的cookie也是不一样的，
					第三个就是有效期，过了有效期就会失效
					
				如何删除一个Cookie值？
					让Cookie过期算删除
					
				HTTPS是如何保证数据不被窃听的	
					
					他是通过数据加密的方式在客户端和服务端进行通信会协商一个加密协议那通过这个加密协议去传输所有的数据传输过程中这些所有的数据都是加密的那第三方也就
					没办法进行窃听，或者更准确一点说第三方可以窃听加密后的数据但是没办法知道加密前原始数据是什么
				
				HTTPS是如果保证不被中间人攻击的
					所谓中间人攻击就是虽然你的客户端和服务端是加密的，但是我可以有一个角色放在中间即充当客户端又充当服务端然后我就可以拦劫客户端的通信进行解密，解
					密完之后我从新加密在给到服务端这样的话你两边看到的都是加密的数据但其实中间经过了中间人这样的角色
					那https是怎样去防御中间人攻击的呢主要是通过一个证书机制。也就是说服务器你的证书的是由可信的CA，数据证书中心签发的而浏览器验证你的证书是不是由
					可信的ca来签发的如果是那我认为你确实是一个合法的服务器如果不是那可能你就是一个伪造的服务器ca和证书机制呢就是保证我们的https不被中间人攻击的关键。
					
				部署https步骤	
					第一步是要确保你的全站都可以部署到https因为部署一部分https它的意义有限有可能没有加密的部分仍然会被攻击产生安全风险，所以需要先确保所有的地方都
					可以使用https访问。这里面最麻烦的地方就是你的资源引用比如我页面中有一个图片它以前是用http访问的那现在你必须需要保证它能够通过https访问
					那这样的工程其实是比较庞大的会涉及到所有资源的改造。那在做完这步之后就需要找cs生成一个证书因为这样才能证明我们是一个合法的服务器并且这个证书才
					会被流量器所信任，申请完证书之后就是将他部署到我们的服务器上面
					
				sql注入的原理是什么
					sql注入是一个非常重点的安全内容所有这里面大家都花一点时间去关注首先第一点就是sql注入的原理 
					sql注入的原理和XSS的原理非常像，他就是用户查询本来这查询它应该是一个数据，但这个数据变成了查询语句本身的一部分导致我们这个查询语句的语义被改变从
					而产生一些意料之外的查询结果那就是sql注入的原理	
				
				sql注入的危害
					既然我们的语意被改变我们就可以查询出各种各样的数据，也就是说会输出一些我们本来不愿意输出给用户的数据，那最轻的情况就是导致页面逻辑出现异常那严
					重一些的就是导致我们泄露一些数据给到没有权限的用户。那最严重的情况就是导致我们整个数据的泄露会产生脱库这样的情况。
					当然中间像用户的密码泄露啊什么用户登录太泄露啊那这个就是非常顺水推舟的事情了
				
				在PHP中怎样去防御sql注入？
					第一种方法就是转义，但是转义是不彻底的方式总有一些情况可能会被绕过。
					第二种方式就是通过orm就是数据关系模型这样的系统去做这样的话我们就不需要直接去操作sql语句
					第三种方式就是通过数据库提供的一种叫做参数化查询的能力，所谓参数化查询就是把一个原本拼起来的sql 变成两个部分，第一给部分是表示我查询的意图是什
					么也就是我的sql语句是张什么样的，第二个部分就是我这个sql语句中出现的条件它的条件值是什么
					这样的话通过将意图跟数据分开我们就不会产生用户的数据被当成语句的一部分改变sql的意图这样的风险，
					所以最彻底的方法就是使用orm一种是使用参数化查询相对来说参数化查询会更保险一些同样在PHP中也是通过这几种方式。
				
				文件上传漏洞
					文件上传的漏洞的原理是什么？
					就是我上传了一个文件然后这个文件在次被访问的时候被当成了一个程序去执行那这个过程中就有可能去执行用户的一些恶意代码影响我们的正常逻辑比如泄露数据
					泄露逻辑甚至导致我们的数据库被下载等等这个还是非常严重的
				如何方法文件上传漏洞？
					主要是通过判断的方式来做，比如判断文件的后缀名是不是合法的判断文件的类型是不是合法的那这两个，还是可以很轻易的绕过的。那接下来的一些方法比如说判
					断文件头对不对他是不是我们想要的类型这种也有可能被绕过所以比较靠谱的方法就是通过设置权限的方式让上传的文件没有可执行权限
					那这个是有一些语言是适用的有一些语言是不适用的，那最好的办法就是适用程序来读取我们的文件也就是不要让这个文件有配可执行的机会，但你也可以通过分离
					文件文件存储的方式来做。那这个文件只是被存储的那台服务器，只关注的那台数据永远不会有机会去执行他。
					
				如何设计用户的密码存储库？
					最重要的一点就是一定不要用明文存储密码一定要用单向哈希，那这个单向哈希就会涉及到强度的问题我们会适用一些方式比如多次哈希然后加盐等等这样的方式去
					增强它的强度所以密码的存储最主要的关注的一个点就是我们必须要去做哈希并且需要有足够大的强度那这个强度就需要密码的复杂度以及加盐来保障
					所以加盐也是非常非常重要的一个操作
				如果去设计登录的过程呢？
					只要保证这里的明文密码是不能够对比和存储的，那既然明文密码不能被对比和存储所以登录过程中也是需要用户的密码用和存储相同的方式进行哈希哈希之后然后
					去对比看跟用户存储的这个哈希是不是相同的千万不能使用明文直接去对比这也是最关键的一个点那同时我们也讲到了在登录过程中的加密也就涉及到第三个问题。如何保证用户密码不被窃听？
				如何保证用户密码不被窃听？	
					这里主要是通过两个渠道第一个通过https加密的方式那这个过程中是可以保证传输过程中是不被窃听的。
					第二种就是，如果说用户密码有被窃听的可能怎样保证用户的原文，就是明文不被窃听那我们就是通过客户端加密的方式当然这种客户端的加密对于这种登录太的
					泄露意义是有限的但是对于用户的明文密码是有一定的保护作用的
					
					
					
					
					
					
SEO VIP视频教程 seo研究中心 网站优化教程						
http://www.itjiaocheng.com/youzhi/2951.html   				30
					
					
传智播客 尹成 C语言从菜鸟到高手					
http://www.itjiaocheng.com/youzhi/3112.html					20
					

Kali Linux Web 渗透测试视频教程								5					
http://www.itjiaocheng.com/youzhi/838.html		链接失效			
http://www.itjiaocheng.com/coin/download.php?open=0&aid=838					

欺骗的艺术-黑客社工教程										5
http://www.itjiaocheng.com/youzhi/907.html	链接失效
http://www.itjiaocheng.com/coin/download.php?open=0&aid=907




Linux高级系统内核架构师系列视频课程							20 
http://www.itjiaocheng.com/youzhi/918.html   链接失效
http://www.itjiaocheng.com/coin/download.php?open=0&aid=918




Shell高级编程实战技术视频教程下载						    5
http://www.itjiaocheng.com/youzhi/941.html  


好男人，你也要学会撩妹
http://www.itjiaocheng.com/youzhi/976.html	                10


中国科技大学Linux内核分析 2017年							5
http://www.itjiaocheng.com/youzhi/977.html 



2500 元网易白帽子											10 
http://www.itjiaocheng.com/youzhi/1200.html


最新redis实战视频教程 redis布式架构从入门到精通视频教程		2
http://www.itjiaocheng.com/youzhi/1672.html（在考虑）



LINUX安全+网络安全实战教程 小飞侠老师网络项目实训营第三期精华课程   15
http://www.itjiaocheng.com/youzhi/2340.html


达内linux运维工程师												20
http://www.itjiaocheng.com/youzhi/2463.html


HTTP协议原理+实践 Web开发工程师必学								5 
http://www.itjiaocheng.com/youzhi/2608.html


 sss论坛渗透培训之基础系列教程									2
http://www.itjiaocheng.com/youzhi/2688.html


sss论坛渗透培训之SQLMP系列教程									2 
http://www.itjiaocheng.com/youzhi/2687.html



迪科实地渗透培训班第一期(价值4500)								15
http://www.itjiaocheng.com/youzhi/2686.html


智能社Javaｓｃｒｉｐｔ专题： Vue.JS七天基础培训视频教程			5
http://www.itjiaocheng.com/youzhi/2962.html



燕十八前端教程 mongodb nginx oracle 							10
http://www.itjiaocheng.com/youzhi/3001.html



 国际认证Linux系统网络工程师培训								15
http://www.itjiaocheng.com/youzhi/3658.html


Vue.js 源码全方位深入解析										10
http://www.itjiaocheng.com/youzhi/3116.html


288元Redis从入门到高可用，分布式实践 企业级Redis开发运维				10
http://www.itjiaocheng.com/youzhi/1884.html			以下载	
					
				














			
				
			